#version 460 core
#extension GL_ARB_shader_image_load_store : enable
layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

//layout (binding = 0, rgba8) uniform image3D baseTexture;
layout (binding = 0, rgba8) uniform image3D mipTextures[5]; // Assuming 5 mipmap levels, adjust as needed

shared vec4 sharedVoxels[8*8*8]; // Adjust size based on local_size_x, y, z

uniform int VoxelDimensions;
uniform int MipLevels;
uniform int MipLevelDimensions[5];
uniform int divisorOfMaxSize;
uniform int currentLevel; // Pass the current mipmap level to work on

uniform ivec3 DispatchOffset;



void main() {
    ivec3 localIdx = ivec3(gl_LocalInvocationID.xyz);
    ivec3 globalIdx = ivec3(gl_GlobalInvocationID.xyz);
    ivec3 lowResID = globalIdx >> 1;  // Compute low-resolution index for the next level mipmap

    int flatIndex = localIdx.x + (localIdx.y * 8) + (localIdx.z * 64);  // Flatten the local index for shared memory access

    // Load voxel data into shared memory from the current mipmap level
    sharedVoxels[flatIndex] = imageLoad(mipTextures[currentLevel], globalIdx);
    memoryBarrierShared();
    barrier();

    // Ensure only threads that correspond to reducing 2x2x2 blocks execute the averaging
    if (localIdx.x % 2 == 0 && localIdx.y % 2 == 0 && localIdx.z % 2 == 0) {
        vec4 sum = vec4(0.0);
        for (int z = 0; z < 2; z++) {
            for (int y = 0; y < 2; y++) {
                for (int x = 0; x < 2; x++) {
                    int idx = (localIdx.x + x) + ((localIdx.y + y) * 8) + ((localIdx.z + z) * 64);
                    sum += sharedVoxels[idx];
                }
            }
        }
        sum /= 8.0;

        // Store the computed average to the next level mipmap
        if (sum.a > 0.05) {  // Store only if alpha is greater than a threshold (to handle sparse data)
            imageStore(mipTextures[currentLevel + 1], lowResID, sum);
        }
    }
}